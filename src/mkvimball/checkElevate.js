/*
 * This file is placed in the public domain.
 *
 * Generated by the mkvimball vim script
 * (www.vim.org/scripts/script.php?script_id=4219).
 *
 * Windows JScript file to check if current user has
 * administrator privileges on Windows XP (for later
 * Windows versions the Manatory Label displayed by
 * the whoami /groups command can be checked instead).
 */

// input file contents marker: a7ec181d243150b7e40823f224174a281f46e986
// checkElevate script marker: 50b5dc8a71e22da68cfc83bc1904bdbe2297720e

if
    (
	typeof WScript == 'undefined' || WScript == null
	    ||
	typeof GetObject == 'undefined' || GetObject == null
    )
{
    throw 'This script runs under Windows Script Host (WSH) with Windows Management Instrumentation (WMI).';
}

try
{
    if (WScript.Arguments.Count() < 1)
    {
	WScript.StdErr.WriteLine("Usage: " + WScript.ScriptName + " | cmd-name | args...");
	WScript.StdErr.WriteLine("Requests elevation for running cmd-line...");
	WScript.Quit(5);
    }

    var WshShell = WScript.CreateObject("WScript.Shell");

    // Try to invoke `whoami /gropus` (for Windows Vista and later)
    //
    // This is not exactly the search algorithm from cmd.exe or ::CreateProcess API, which
    // iterate the path directories first, than the %PATHEXT% list for each of the dirs..,
    // but it still finds the executable or command script
    var whoamiCmd =
	'"' + WshShell.Environment('PROCESS')('ComSpec') + '"'
	    +
	' /V:ON /S /C "For %i in (.EXE %PATHEXT:;= %) Do @For %j in (whoami%i) Do @If Not x"%~$PATH:j" == x"" ("%~$PATH:j" /groups & Exit !ErrorLevel!)"';
    WScript.StdOut.WriteLine(whoamiCmd);
    var oExec = WshShell.Exec(whoamiCmd);
    oExec.StdIn.Close();	// Send End-Of-Input to child process
    var groupsList = oExec.StdOut.ReadAll();
    var messages = oExec.StdErr.ReadAll();
    WScript.StdOut.Write(groupsList);
    if (oExec.ExitCode || messages.replace(/(\s|\r|\n\v|\f)/g, '') != '')
    {
	// `whoami /gropups` returned some error
	WScript.StdErr.Write(messages);
	if (oExec.ExitCode)
	    WScript.Quit(oExec.ExitCode);
	else
	    WScript.Quit(6);
    }

    if (groupsList.replace(/(\s|\r|\n\v|\f)/g, '') != '')
    {
	// List of groups received from `whoami /gropus`
	var mandatoryLevel = groupsList.match(/\s+S-1-16-([0-9]+)\s+/);

	if (mandatoryLevel == 'null')
	{
	    WScript.StdErr.WriteLn("Mandatory Level Security Label missing from the current groups list.");
	    WScript.Quit(3);
	}

	if (String(parseInt(mandatoryLevel[1])) != mandatoryLevel[1])
	{
	    WScript.StdErr.WriteLn("Mandatory Level Security Label not understood.");
	    WScript.Quit(4);
	}

	if (parseInt(mandatoryLevel[1]) >= 12288)
	    // process is elevated
	    WScript.Quit(197);

	// request elevation
    }
    else
    {
	// `whoami` not available, read groups list with WMI
	var WshNetwork = WScript.CreateObject("WScript.Network");
	var userDomain = WshNetwork.UserDomain;
	var userName = WshNetwork.UserName;

	if (userDomain == '' || userName == '')
	{
	    WScript.StdErr.Write('Failed to read current user name and domain.');
	    WScript.Quit(1);
	}

	var objWMIService = GetObject("winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\cimv2");

	// Read name and domain for the well-known SID of the Administrators group
	var colAdminAccount =
	    objWMIService.ExecQuery("Select * From Win32_Group Where LocalAccount = TRUE And SID='S-1-5-32-544'");
	var adminsName;
	var adminsDomain;

	for (var enumItems = new Enumerator(colAdminAccount); !enumItems.atEnd(); enumItems.moveNext())
	{
	    var objAccount = enumItems.item();
	    adminsName = objAccount.Name;
	    adminsDomain = objAccount.Domain;
	}

	if (adminsName == '' || adminsDomain == '')
	{
	    WScript.StdErr.Write('Failed to read name and domain for the local Administrators group.');
	    WScript.Quit(2);
	}

	// Enumerate all group users that:
	// - have the name and domain of the current user
	// - have the group and domain names of the local Administrators group
	var colAccounts =
	    objWMIService.ExecQuery
		(
		    "Select * "
			+
		    "From Win32_GroupUser "
			+
		    "Where "
			+
			"PartComponent=\"Win32_UserAccount.Domain='" + userDomain + "',Name='" + userName + "'\""
			    +
			" AND "
			+
			"GroupComponent=\"Win32_Group.Domain='" + adminsDomain + "',Name='" + adminsName + "'\""
		);

	for (var enumItems = new Enumerator(colAccounts); !enumItems.atEnd(); enumItems.moveNext())
	{
	    // User matches both conditions (current user belongs to the local Admins group
	    WScript.Quit(197);	// no elevation needed, continue
	}

	// Current user does not match conditions (no Admins group), request elevation
    }

    // Read process command line
    if (!objWMIService)
	var objWMIService = GetObject("winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\cimv2");

    var childProcess =
	WshShell.Exec
	    (
		'"' + WshShell.Environment('PROCESS')('ComSpec') + '"'
		    +
		" /S /C \"Echo \"Text lines\" && Set /p VarName=\""
	    );
    childProcess.StdOut.ReadLine();
    var current_pid =
	    objWMIService.ExecQuery
		(
		    "SELECT * FROM Win32_Process WHERE ProcessId=" + childProcess.ProcessID
		);
    current_pid = (new Enumerator(current_pid)).item().ParentProcessId
    if (current_pid)
	childProcess.StdIn.WriteLine("value");	// child process should now exit
    else
    {
	WScript.StdErr.WriteLine("Get current PID from WMI failed.");
	WScript.Quit(7);
    }

    var cmd_line = objWMIService.ExecQuery("SELECT * FROM Win32_Process WHERE ProcessID=" + current_pid);
    cmd_line = (new Enumerator(cmd_line)).item().CommandLine
    if (!cmd_line)

    {
	WScript.StdErr.WriteLine("Reading current command line with WMI failed.");
	WScript.Quit(8);
    }

    var cmd_name = cmd_line.match(/^[^|]*\|\s*([^|]+)\s*\|(.*)$/);

    if (cmd_name)
    {
	cmd_line = cmd_name[2];
	cmd_name = cmd_name[1];
    }
    else
    {
	WScript.StdErr.WriteLine("Usage: " + WScript.ScriptName + " | cmd-name | args...");
	WScript.Quit(9);
    }

    // request elevation
    var ShellApp = WScript.CreateObject("Shell.Application");
    var scriptArgs = "";
    for (var i = 1; i < WScript.Arguments.Count(); i++)
	scriptArgs += '"' + WScript.Arguments(i).replace(/(\\+)"/g, '$1$1"').replace('"', '\\"') + '"';

    WScript.Quit(ShellApp.ShellExecute(cmd_name, cmd_line, null, 'runas', true));
}
catch(ex)
{
    var msg = "Script error.\r\n";
    for (p in ex)
	if (p != 'description')
	{
	    msg += p + ": " + ex[p] + "\r\n";
	}

    try
    {
	WScript.StdErr.Write(msg);
    }
    catch (ex)
    {
	WScript.Echo(msg);
    }

    WScript.Quit(254);
}
